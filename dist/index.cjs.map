{"version":3,"file":"index.cjs","sources":["../src/index.ts"],"sourcesContent":["/**\n * Convert HTML to JSON or Object\n * @author Yousuf Kalim\n */\nimport { DOMParser } from 'xmldom';\n\ninterface JSONContent {\n  type: string;\n  attributes?: object;\n  content: Array<string | JSONContent>;\n}\n/**\n * @param element The HTML string or element to convert to JSON.\n * @param json A boolean to indicate if the output should be a JSON string.\n * @returns {Promise<unknown>}\n */\nasync function HTMLParser(element: Element | string, json = false): Promise<JSONContent | string> {\n  return await new Promise((resolve, reject) => {\n    try {\n      const treeObject: any = {};\n      let elementToParse: Element;\n\n      // If string convert to document Node\n      if (typeof element === 'string') {\n        const parser = new DOMParser();\n        const docNode = parser.parseFromString(element, 'text/xml');\n        if (docNode.firstChild) {\n          elementToParse = docNode.firstChild as Element;\n        }\n      } else {\n        elementToParse = element;\n      }\n\n      // Recursively loop through DOM elements and assign properties to object\n      const treeHTML = (element: Element, object = treeObject): void => {\n        object.type = element.nodeName;\n        const nodeList = element.childNodes;\n        if (nodeList !== null) {\n          if (nodeList.length) {\n            object.content = [];\n            for (let i = 0; i < nodeList.length; i++) {\n              if (nodeList[i].nodeType === 3) {\n                if (nodeList[i].nodeValue) {\n                  object.content.push(nodeList[i].nodeValue);\n                }\n              } else {\n                object.content.push({});\n                treeHTML(nodeList[i] as Element, object.content[object.content.length - 1]);\n              }\n            }\n          }\n        }\n        if (element.attributes !== null) {\n          if (element.attributes.length) {\n            object.attributes = {};\n            for (let i = 0; i < element.attributes.length; i++) {\n              object.attributes[element.attributes[i].nodeName] = element.attributes[i].nodeValue;\n            }\n          }\n        }\n      };\n\n      // @ts-expect-error\n      treeHTML(elementToParse);\n\n      resolve(json ? JSON.stringify(treeObject) : treeObject);\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nexport default HTMLParser;\n"],"names":["HTMLParser","element","json","Promise","resolve","reject","elementToParse","treeObject","docNode","DOMParser","parseFromString","firstChild","treeHTML","object","type","nodeName","nodeList","childNodes","length","content","i","nodeType","nodeValue","push","attributes","_i","JSON","stringify","e"],"mappings":"uCAgBeA,SAAWC,EAA2BC,QAAI,IAAJA,IAAAA,GAAO,GAAK,IAAA,OAAAC,QAAAC,QAClD,IAAWD,QAAC,SAACC,EAASC,GACjC,IACE,IAC2BC,EADrBC,EAAkB,CAAA,EAIxB,GAAuB,iBAAZN,EAAsB,CAC/B,IACMO,GADS,IAAeC,EAAAA,WACPC,gBAAgBT,EAAS,YAC5CO,EAAQG,aACVL,EAAiBE,EAAQG,WAE5B,MACCL,EAAiBL,GAIF,SAAXW,EAAYX,EAAkBY,YAAAA,IAAAA,EAASN,GAC3CM,EAAOC,KAAOb,EAAQc,SACtB,IAAMC,EAAWf,EAAQgB,WACzB,GAAiB,OAAbD,GACEA,EAASE,OAAQ,CACnBL,EAAOM,QAAU,GACjB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAASE,OAAQE,IACN,IAAzBJ,EAASI,GAAGC,SACVL,EAASI,GAAGE,WACdT,EAAOM,QAAQI,KAAKP,EAASI,GAAGE,YAGlCT,EAAOM,QAAQI,KAAK,IACpBX,EAASI,EAASI,GAAeP,EAAOM,QAAQN,EAAOM,QAAQD,OAAS,IAG7E,CAEH,GAA2B,OAAvBjB,EAAQuB,YACNvB,EAAQuB,WAAWN,OAAQ,CAC7BL,EAAOW,WAAa,CAAE,EACtB,IAAK,IAAKC,EAAG,EAAGL,EAAInB,EAAQuB,WAAWN,OAAQE,IAC7CP,EAAOW,WAAWvB,EAAQuB,WAAWJ,GAAGL,UAAYd,EAAQuB,WAAWJ,GAAGE,SAE7E,CAEL,CAGAV,CAASN,GAETF,EAAQF,EAAOwB,KAAKC,UAAUpB,GAAcA,EAG7C,CAFC,MAAOqB,GACPvB,EAAOuB,EACR,CACH,GACD,CAAA,MAAAA,GAAA,OAAAzB,QAAAE,OAAAuB,EAAA,CAAA"}